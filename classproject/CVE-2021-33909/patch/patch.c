#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/cache.h>
#include <linux/fs.h>
#include <linux/export.h>
#include <linux/seq_file.h>
#include <linux/vmalloc.h>
#include <linux/slab.h>
#include <linux/cred.h>
#include <linux/mm.h>
#include <linux/string_helpers.h>
#include <linux/uio.h>

#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/fs_struct.h>
#include <linux/prefetch.h>

#include <linux/kprobes.h>
#include <linux/ptrace.h>

#include <linux/sched.h>
#include <linux/printk.h>

#include <linux/uaccess.h>
#include <asm/page.h>

extern char *dentry_path(struct dentry *, char *, int);

//hook the prepend function to detect negative integer, use unlikely() macro to mitigate the introduced latency
static void *cve_2021_33909_prepend(char **buffer, int *buflen, const char *str, int namelen) {
    //modified here
	if (unlikely(*buflen < 0)) {
        printk( KERN_INFO "cve-2021-33909: prepend() negative detected");
        return -ENAMETOOLONG;
    }

    *buflen -= namelen;
	if (*buflen < 0)
		return -ENAMETOOLONG;
	*buffer -= namelen;
	memcpy(*buffer, str, namelen);
	return 0;
}

//hook the seq_dentry function to check overflow
static void *cve_2021_33909_seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc) {
	char *buf;
	size_t size = seq_get_buf(m, &buf);
	int res = -1;

    //modified here
    if (unlikely(size >= INT_MAX)) {
        return res;
    } 
    //else if (size) {
		// char *p = dentry_path(dentry, buf, size);
		// if (!IS_ERR(p)) {
		// 	char *end = mangle_path(buf, p, esc);
		// 	if (end)
		// 		res = end - buf;
		// }
	//}
	seq_commit(m, res);

	return res;
}

static int cve_2021_33909_prepend_hook(struct kprobe *p, struct pt_regs *regs) {
    instruction_pointer_set(regs, (unsigned long)cve_2021_33909_prepend);
    return 1;
}

static int cve_2021_33909_seq_dentry_hook(struct kprobe *p, struct pt_regs *regs) {
    instruction_pointer_set(regs, (unsigned long)cve_2021_33909_seq_dentry);
    return 1;
}

static struct kprobe prepend_hook = {
    .symbol_name    = "prepend",
    .pre_handler    = cve_2021_33909_prepend_hook,
};
static struct kprobe seq_dentry_hook = {
    .symbol_name    = "seq_dentry",
    .pre_handler    = cve_2021_33909_seq_dentry_hook,
};


static int __init cve_2021_33909_init(void) {
    int ret = 0;
    //register kprobes
    ret = register_kprobe(&prepend_hook);
    if(ret < 0) {
        printk(KERN_ALERT "cve-2021-33909 patch module init failed!\n");
        return ret;
    }

    ret = register_kprobe(&seq_dentry_hook);
    if(ret < 0) {
        printk(KERN_ALERT "cve-2021-33909 patch module init failed!\n");
        //if the second hook failed, also undo the first one.
        unregister_kprobe(&prepend_hook);
        return ret;
    }

    printk(KERN_INFO "cve-2021-33909 patch module installed!\n");

    return 0;
}

static void __exit cve_2021_33909_exit(void) {
    printk(KERN_INFO "cve-2021-33909 patch module uninstalled!\n");

    unregister_kprobe(&seq_dentry_hook);
    unregister_kprobe(&prepend_hook);
}


module_init(cve_2021_33909_init);
module_exit(cve_2021_33909_exit);

MODULE_LICENSE( "GPL" );
MODULE_AUTHOR( "CSE522S" );
MODULE_DESCRIPTION( "cve-2021-33909 patch" );
